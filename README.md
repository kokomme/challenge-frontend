# Challenge Frontend

## 使用技術と選定理由

### UIフレームワーク

**React 19.2.0** を採用

**選定理由:** コンポーネント単位で再利用性が高くエコシステムが充実しているため。また、既に使用経験があり、導入や開発の学習コストが低いことも理由の一つです。

### 型システム

**TypeScript 5.9.3** を採用


**選定理由:** 型チェックでバグを早期に検出でき、保守性と開発効率が向上するため。


### ビルドツール

**Vite 7.2.4** を採用


**選定理由:** 起動が高速でHMRにより開発体験が向上するため。


### スタイリング

**Tailwind CSS 4.1.17** を採用

**選定理由:** ユーティリティクラスで迅速に一貫したスタイルを実装できるため。

### データフェッチング・状態管理

**TanStack Query (React Query) 5.90.12** を採用

**選定理由:** サーバー状態のキャッシュや再取得、ローディング管理を簡潔に扱えるため。
**現在の実装での活用:**
- データ作成・更新・削除後に`invalidateQueries`でキャッシュを無効化
- 自動で最新データを再取得し、UIに反映
- `staleTime`を1分に設定し、頻繁な再フェッチを抑制

**他の選択肢との比較:**
- **useEffect + useState**: 自分で実装すると、キャッシュやローディング状態の管理が煩雑

### HTTP クライアント

**Axios 1.13.2** を採用

**選定理由:** エラーハンドリングやインターセプターでHTTP処理を一箇所で管理しやすいため。

### テストフレームワーク

**Vitest 4.0.15** を採用

**選定理由:** Viteと統合され高速に動作するためテスト実行が速く開発効率が上がる。

**@testing-library/react 16.3.0** を採用

**選定理由:** ユーザー視点で安定したテストが書けるため。

**MSW (Mock Service Worker) 2.12.4** を採用

**選定理由:** テストや開発でネットワークリクエストに近い形でAPIをモックできるため。

### コード品質管理

**ESLint 9.39.1** を採用

**選定理由:** 静的解析で潜在的なバグやスタイル違反を早期に検出できるため。

**Husky + lint-staged** を採用

**選定理由:** コミット前に自動でLintを実行して品質低下を防げるため。

**仕組み:**
- lint-staged: ステージングされたファイルのみをLint（高速）

## 環境構築

### 前提条件
- Node.js 24.11.1
- バックエンドAPI（http://localhost:3000）が起動していること

### 手順

```bash
# 依存関係のインストール
npm install

# 開発サーバーの起動
npm run dev
```

アプリケーションは http://localhost:5173 で起動します。

### テストの実行

```bash
npm run test
```

## 設計思想

### なぜこの設計にしたか

このアプリでは「変更に強く、テストしやすいコード」を目指しました。そのために以下の設計を採用しています。

### フォルダ構成

機能ごとにフォルダを分ける**Feature-based設計**を採用しました。

```
src/
├── features/          # 機能ごとのコード
│   ├── content/      # ページ本文の機能
│   │   ├── api/      # API呼び出し
│   │   ├── components/ # 画面表示
│   │   ├── context/  # データ共有
│   │   ├── hooks/    # ビジネスロジック
│   │   └── types/    # 型定義
│   └── sidebar/      # サイドバーの機能
├── components/       # 複数の場所で使う部品
├── lib/             # 便利な関数
└── route/           # ページ全体
```

**この設計のメリット:**
- 関連するコードが近くにあるので探しやすい
- 機能を追加・削除するときに影響範囲が明確
- 別のプロジェクトに機能を移植しやすい

### 具体的な実装方針

#### 1. 役割を明確に分ける

コードを3つの層に分けています:

- **API層** (`features/*/api/`)
  - バックエンドとの通信だけを担当
  - 他の部分はAPIの詳細を知らなくてよい
  
- **ロジック層** (カスタムフック: `useContents`, `useCreateContent`等)
  - データの取得・加工・更新の処理を担当
  - TanStack Queryでキャッシュ管理と再取得の制御を実装
  
- **表示層** (コンポーネント)
  - 画面の表示だけを担当
  - データがどこから来るかは気にしない

#### 2. データの持ち方を使い分ける

データの性質に応じて管理方法を変えています:

- **サーバーのデータ** → TanStack Query
  - ページ一覧、選択中のページ内容など
  - データをキャッシュし、更新後に自動で再取得される
  
- **アプリ全体で使うデータ** → React Context
  - 「今どのページを見ているか」の情報
  - どのコンポーネントからでも参照・更新できる
  
- **そのコンポーネントだけのデータ** → useState
  - 編集中のタイトル、編集モードのON/OFFなど
  - 他のコンポーネントに影響を与えない


#### 3. 部品を再利用できるようにする

小さな部品（Buttonなど）を作り、組み合わせて画面を構築:

```tsx
// 悪い例: 同じようなボタンを何度も書く
<button className="bg-blue-500...">保存</button>
<button className="bg-blue-500...">キャンセル</button>

// 良い例: 共通の部品を使う
<Button variant="primary">保存</Button>
<Button variant="secondary">キャンセル</Button>
```

#### 5. エラーは早く見つけて、わかりやすく伝える

- **入力エラー**: その場ですぐ表示（文字数オーバーなど）
- **通信エラー**: Axiosのインターセプターで統一的に処理
- **型エラー**: TypeScriptがコンパイル時に検出

## 実装した機能

### 必須要件
- ✅ サイドバーに全ページを表示
- ✅ 「+」ボタンで新規ページ作成
- ✅ 「-」ボタンでページ削除
- ✅ タイトルと本文の編集・保存
- ✅ バリデーション（タイトル: 1-50文字、本文: 10-2000文字）
- ✅ テストコードの実装（7つのテストケース）

### 追加実装した機能
1. **文字数カウンター**: 編集中にリアルタイムで文字数を表示
2. **自動選択**: ページがない場合、最初のページを自動選択
3. **ローディング状態**: データ取得中の適切なフィードバック


## テスト仕様

合計7つのテストケースを実装しています。詳細は[TEST_DOCUMENTATION.md](./TEST_DOCUMENTATION.md)を参照。

- **バリデーション**: 境界値分析（3テスト）
- **API通信**: CRUD操作の検証（2テスト）
- **UIコンポーネント**: インタラクションとレイアウト（2テスト）
